#pragma once

#include<iostream>
#include<string>
#include<fstream>

#include<opencv2\core\core.hpp>
#include<opencv2\opencv.hpp>
#include<opencv2\imgproc\imgproc.hpp>
#include<opencv2\ml\ml.hpp>
#include<opencv2\highgui\highgui.hpp>

#include<ml\ml.hpp>
#include"Kmeans.h"

class myLBVLD {
private:

	int block_stride;        //The step size of the sliding window of the block, which is set to half the length of the block by default;

	cv::Mat src_img;          //Read the source picture;

	std::vector<cv::Mat> train_images;

	int D1;

	int D2;

	cv::Size Block_num;            //The number of DFD regions divided by one picture;

	cv::Size Block_Size;           //The size of each DFD area;

	int perImg_PDM_Num;            //Represents the number of PDM generated by each picture;

	std::vector<double> DFD_vec;   //The resulting DFD features;

								   //int featureDim;                Get DFD_vec dimension for each photo;

	std::vector<cv::Mat> W;

	std::vector<cv::Mat> V;

	std::vector<cv::Mat>W1;
	std::vector<cv::Mat>V1;

	std::vector<cv::Mat>W2;
	std::vector<cv::Mat>V2;

	std::vector<cv::Mat>W3;
	std::vector<cv::Mat>V3;



	void myNet(cv::Mat A);

	void Extract_PDM();     //Extract the PDM matrix from a picture image;

	cv::Mat Create_PDM(int i, int j);         //Generate a corresponding PDM matrix;

	void DFD_Train();                    //Perform DFD feature training;

	void _2D_LDA(cv::Mat A);         //2D_LDA algorithm iterates;
	std::vector<cv::Mat> _2D_LDA(std::vector<cv::Mat>A,int w_cols,int v_cols,int tag);         //2D_LDA algorithm iterates;
	void _2D_LDA_new(cv::Mat A);

	void Compute_DFDVec();               //Based on the trained data, we generate the DFD feature vector DFD_vec
	void Compute_DFDVec_new();

	void knn_classification();   //KNN trainer for classification calculation;

	void SVM_classification();

	void Kmeans_classification();
	void LR_classification();

	cv::Mat NormalizeVec(cv::Mat Vec);    //Normalization of feature vectors;

	cv::Mat Extract_PDM(cv::Mat img);    //Extract PDM matrix from a picture
	cv::Mat Extract_PDM_new(cv::Mat img);

	cv::Mat Mat_Map_HashBinary(cv::Mat img);   //Map the Mat matrix into a hash binary matrix;

	cv::Mat sign_B(cv::Mat A);  //Map ordinary matrix to binary matrix;

	cv::Mat Compute_Mean_of_Matrix(cv::Mat A);

	//Three different activation functions;
	float Sign_Activation(float i);
	float Sigmod_Activation(float i);
	float tanH_Activation(float i);

	std::vector<cv::Mat> learn_w(std::vector<cv::Mat>A, cv::Mat  &w, cv::Mat v);
	std::vector<cv::Mat> learn_v(std::vector<cv::Mat>A, cv::Mat  w, cv::Mat &v);
	std::vector<cv::Mat> learn_w_and_v(std::vector<cv::Mat>A, cv::Mat  &w, cv::Mat &v);
	void CreateNet(cv::Mat A);
	float Createloss(std::vector<cv::Mat>A, cv::Mat  w, cv::Mat v);
	float loss_2(std::vector<cv::Mat>A, cv::Mat  w, cv::Mat v);

	cv::Mat codebook1;
	cv::Mat codebook2;
	cv::Mat codebook3;
	void cluster();
	void Compute_DFDVec_KMeans();
	cv::Mat extractPDM_KMeans(cv::Mat img);
	int compute_Dis(cv::Mat A,cv::Mat codebook);

	void duoxianchenglala(int i);



public:
	myLBVLD();

	void Process();             //Sample data preprocessingand other related content
};
